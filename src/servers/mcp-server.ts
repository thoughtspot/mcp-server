import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
    ToolSchema,
    ListResourcesRequestSchema,
    ReadResourceRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import type { Props } from "../utils";
import { getThoughtSpotClient } from "../thoughtspot/thoughtspot-client";
import {
    ThoughtSpotService
} from "../thoughtspot/thoughtspot-service";
import { MixpanelTracker } from "../metrics/mixpanel/mixpanel";
import { Trackers, type Tracker, TrackEvent } from "../metrics";
import { context, type Span, SpanStatusCode, trace } from "@opentelemetry/api";
import { WithSpan } from "../metrics/tracing/tracing-utils";

const ToolInputSchema = ToolSchema.shape.inputSchema;
type ToolInput = z.infer<typeof ToolInputSchema>;

const PingSchema = z.object({});

const GetRelevantQuestionsSchema = z.object({
    query: z.string().describe("The query to get relevant data questions for, this could be a high level task or question the user is asking or hoping to get answered. Do minimal processing of the original question. You can even pass the complete raw query as it is, the system is smart to make sense of it as it has access to the entire schema. Do not add analytical hints or directions."),
    additionalContext: z.string()
        .describe("Additional context to add to the query, this might be older data returned for previous questions or any other relevant context that might help the system generate better questions.")
        .optional(),
    datasourceIds: z.array(z.string())
        .describe("The datasources to get questions for, this is the ids of the datasources to get data from. Each id is a GUID string.")
});

const GetAnswerSchema = z.object({
    question: z.string().describe("The question to get the answer for, these are generally the questions generated by the getRelevantQuestions tool."),
    datasourceId: z.string()
        .describe("The datasource to get the answer for, this is the id of the datasource to get data from")
});

const CreateLiveboardSchema = z.object({
    name: z.string().describe("The name of the liveboard to create"),
    answers: z.array(z.object({
        question: z.string(),
        session_identifier: z.string(),
        generation_number: z.number(),
    })).describe("The answers to create the liveboard from, these are the answers generated by the getAnswer tool."),
});

enum ToolName {
    Ping = "ping",
    GetRelevantQuestions = "getRelevantQuestions",
    GetAnswer = "getAnswer",
    CreateLiveboard = "createLiveboard",
}

interface Context {
    props: Props;
}

export class MCPServer extends Server {
    private trackers: Trackers = new Trackers();
    private sessionInfo: any;
    constructor(private ctx: Context) {
        super({
            name: "ThoughtSpot",
            version: "1.0.0",
        }, {
            capabilities: {
                tools: {},
                logging: {},
                completion: {},
                resources: {},
            }
        });
    }

    private getThoughtSpotService() {
        return new ThoughtSpotService(getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken));
    }

    async init() {
        this.sessionInfo = await this.getThoughtSpotService().getSessionInfo();
        const mixpanel = new MixpanelTracker(
            this.sessionInfo,
            this.ctx.props.clientName
        );
        this.addTracker(mixpanel);
        this.trackers.track(TrackEvent.Init);

        this.setRequestHandler(ListToolsRequestSchema, async () => {
            return this.listTools();
        });

        this.setRequestHandler(ListResourcesRequestSchema, async () => {
            return this.listResources();
        });

        this.setRequestHandler(ReadResourceRequestSchema, async (request: z.infer<typeof ReadResourceRequestSchema>) => {
            return this.readResource(request);
        });

        // Handle call tool request
        this.setRequestHandler(CallToolRequestSchema, async (request: z.infer<typeof CallToolRequestSchema>) => {
            return this.callTool(request);
        });
    }

    @WithSpan('list-tools')
    async listTools() {
        const span = trace.getSpan(context.active());
        span?.setAttribute("user_guid", this.sessionInfo.userGUID);
        span?.setAttribute("instance_url", this.ctx.props.instanceUrl);
        return {
            tools: [
                {
                    name: ToolName.Ping,
                    description: "Simple ping tool to test connectivity and Auth",
                    inputSchema: zodToJsonSchema(PingSchema) as ToolInput,
                },
                {
                    name: ToolName.GetRelevantQuestions,
                    description: "Get relevant data questions from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetRelevantQuestionsSchema) as ToolInput,
                },
                {
                    name: ToolName.GetAnswer,
                    description: "Get the answer to a question from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetAnswerSchema) as ToolInput,
                },
                {
                    name: ToolName.CreateLiveboard,
                    description: "Create a liveboard from a list of answers",
                    inputSchema: zodToJsonSchema(CreateLiveboardSchema) as ToolInput,
                }
            ]
        };
    }

    @WithSpan('list-datasources')
    async listResources() {
        const span = trace.getSpan(context.active());
        span?.setAttribute("user_guid", this.sessionInfo.userGUID);
        span?.setAttribute("instance_url", this.ctx.props.instanceUrl);
        const sources = await this.getDatasources();
        return {
            resources: sources.list.map((s) => ({
                uri: `datasource:///${s.id}`,
                name: s.name,
                description: s.description,
                mimeType: "text/plain"
            }))
        };
    }

    @WithSpan('read-datasources')
    async readResource(request: z.infer<typeof ReadResourceRequestSchema>) {
        const span = trace.getSpan(context.active());
        span?.setAttribute("user_guid", this.sessionInfo.userGUID);
        span?.setAttribute("instance_url", this.ctx.props.instanceUrl);
        const { uri } = request.params;
        const sourceId = uri.split("///").pop();
        if (!sourceId) {
            throw new Error("Invalid datasource uri");
        }
        const { map: sourceMap } = await this.getDatasources();
        const source = sourceMap.get(sourceId);
        if (!source) {
            throw new Error("Datasource not found");
        }
        return {
            contents: [{
                uri: uri,
                mimeType: "text/plain",
                text: `
                ${source.description}

                The id of the datasource is ${sourceId}.

                Use ThoughtSpot's getRelevantQuestions tool to get relevant questions for a query. And then use the getAnswer tool to get the answer for a question.
                `,
            }],
        };
    }

    @WithSpan('call-tool')
    async callTool(request: z.infer<typeof CallToolRequestSchema>) {
        const { name } = request.params;
        this.trackers.track(TrackEvent.CallTool, { toolName: name });

        const span = trace.getSpan(context.active());
        span?.setAttribute("instance_url", this.ctx.props.instanceUrl);
        span?.setAttribute("user_guid", this.sessionInfo.userGUID);

        switch (name) {
            case ToolName.Ping: {
                console.log("Received Ping request");
                if (this.ctx.props.accessToken && this.ctx.props.instanceUrl) {
                    span?.setStatus({ code: SpanStatusCode.OK, message: "Ping successful" });
                    return {
                        content: [{ type: "text", text: "Pong" }],
                    };
                }
                span?.setStatus({ code: SpanStatusCode.ERROR, message: "Ping failed" });
                return {
                    isError: true,
                    content: [{ type: "text", text: "ERROR: Not authenticated" }],
                };
            }
            case ToolName.GetRelevantQuestions: {
                return this.callGetRelevantQuestions(request);
            }

            case ToolName.GetAnswer: {
                return this.callGetAnswer(request);
            }

            case ToolName.CreateLiveboard: {
                return this.callCreateLiveboard(request);
            }

            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }

    @WithSpan('call-get-relevant-questions')
    async callGetRelevantQuestions(request: z.infer<typeof CallToolRequestSchema>) {
        const { query, datasourceIds: sourceIds, additionalContext } = GetRelevantQuestionsSchema.parse(request.params.arguments);
        console.log("[DEBUG] Getting relevant questions for datasource: ", sourceIds);
        const span = trace.getSpan(context.active());
        span?.setAttribute("datasource_ids", sourceIds);

        const relevantQuestions = await this.getThoughtSpotService().getRelevantQuestions(
            query,
            sourceIds!,
            additionalContext ?? ""
        );

        if (relevantQuestions.error) {
            span?.setStatus({ code: SpanStatusCode.ERROR, message: `Error getting relevant questions ${relevantQuestions.error.message}` });
            return {
                isError: true,
                content: [{ type: "text", text: `ERROR: ${relevantQuestions.error.message}` }],
            };
        }

        if (relevantQuestions.questions.length === 0) {
            span?.setStatus({ code: SpanStatusCode.OK, message: "No relevant questions found" });
            return {
                content: [{ type: "text", text: "No relevant questions found" }],
            };
        }
        span?.setStatus({ code: SpanStatusCode.OK, message: "Relevant questions found" });
        return {
            content: relevantQuestions.questions.map(q => ({
                type: "text",
                text: `Question: ${q.question}\nDatasourceId: ${q.datasourceId}`,
            })),
        };
    }

    @WithSpan('call-get-answer')
    async callGetAnswer(request: z.infer<typeof CallToolRequestSchema>) {
        const { question, datasourceId: sourceId } = GetAnswerSchema.parse(request.params.arguments);

        const answer = await this.getThoughtSpotService().getAnswerForQuestion(question, sourceId, false);
        const span = trace.getSpan(context.active());
        span?.setAttribute("datasource_id", sourceId);

        if (answer.error) {
            span?.setStatus({ code: SpanStatusCode.ERROR, message: `Error getting answer ${answer.error.message}` });
            return {
                isError: true,
                content: [{ type: "text", text: `ERROR: ${answer.error.message}` }],
            };
        }

        span?.setStatus({ code: SpanStatusCode.OK, message: "Answer found" });
        return {
            content: [
                { type: "text", text: answer.data },
                {
                    type: "text",
                    text: `Question: ${question}\nSession Identifier: ${answer.session_identifier}\nGeneration Number: ${answer.generation_number}\n\nUse this information to create a liveboard with the createLiveboard tool, if the user asks.`,
                },
            ],
        };
    }

    @WithSpan('call-create-liveboard')
    async callCreateLiveboard(request: z.infer<typeof CallToolRequestSchema>) {
        const { name, answers } = CreateLiveboardSchema.parse(request.params.arguments);
        const liveboard = await this.getThoughtSpotService().fetchTMLAndCreateLiveboard(name, answers);
        const span = trace.getSpan(context.active());
        if (liveboard.error) {
            span?.setStatus({ code: SpanStatusCode.ERROR, message: `Error creating liveboard ${liveboard.error.message}` });
            return {
                isError: true,
                content: [{ type: "text", text: `ERROR: ${liveboard.error.message}` }],
            };
        }
        span?.setStatus({ code: SpanStatusCode.OK, message: "Liveboard created successfully" });
        return {
            content: [{
                type: "text",
                text: `Liveboard created successfully, you can view it at ${liveboard.url}
                
                Provide this url to the user as a link to view the liveboard in ThoughtSpot.`,
            }],
        };
    }

    private _sources: {
        list: DataSource[];
        map: Map<string, DataSource>;
    } | null = null;

    @WithSpan('get-datasources')
    async getDatasources() {
        if (this._sources) {
            return this._sources;
        }

        const sources = await this.getThoughtSpotService().getDataSources();
        this._sources = {
            list: sources,
            map: new Map(sources.map(s => [s.id, s])),
        }
        return this._sources;
    }

    async addTracker(tracker: Tracker) {
        this.trackers.add(tracker);
    }
}
