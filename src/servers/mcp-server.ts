import {
    type CallToolRequestSchema,
    ToolSchema,
    type ReadResourceRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";

import { McpServerError } from "../utils";
import type {
    DataSource
} from "../thoughtspot/thoughtspot-service";
import { TrackEvent } from "../metrics";
import { WithSpan } from "../metrics/tracing/tracing-utils";
import { BaseMCPServer, type Context, type ToolResponse } from "./mcp-server-base";

const ToolInputSchema = ToolSchema.shape.inputSchema;
type ToolInput = z.infer<typeof ToolInputSchema>;

const PingSchema = z.object({});

const GetRelevantQuestionsSchema = z.object({
    query: z.string().describe("The query to get relevant data questions for, this could be a high level task or question the user is asking or hoping to get answered. Do minimal processing of the original question. You can even pass the complete raw query as it is, the system is smart to make sense of it as it has access to the entire schema. Do not add analytical hints or directions."),
    additionalContext: z.string()
        .describe("Additional context to add to the query, this might be older data returned for previous questions or any other relevant context that might help the system generate better questions.")
        .optional(),
    datasourceIds: z.array(z.string())
        .describe("The datasources to get questions for, this is the ids of the datasources to get data from. Each id is a GUID string.")
});

const GetAnswerSchema = z.object({
    question: z.string().describe("The question to get the answer for, these are generally the questions generated by the getRelevantQuestions tool."),
    datasourceId: z.string()
        .describe("The datasource to get the answer for, this is the id of the datasource to get data from")
});

const CreateLiveboardSchema = z.object({
    name: z.string().describe("The name of the liveboard to create"),
    answers: z.array(z.object({
        question: z.string(),
        session_identifier: z.string(),
        generation_number: z.number(),
    })).describe("The answers to create the liveboard from, these are the answers generated by the getAnswer tool."),
    noteTile: z.string().describe(`
        Create a summary of the answers to the queries asked by the user along with all the analysis done on the data.
        The output format is an html note tile which can have custom styles and formatting. Use emojis, styling and icons to make it more visually appealing.
        Follow these MANDATORY rules for styling:
        - Put the whole note tile in a single line and no line breaks. Also there should be no unnecessary white spaces.
        - The html output in the note tile can have white spaces. Use <br> or <tab> if needed to use white spaces in the note tile.
        - Use padding, margin and line height to create space between the elements in the note tile and make it more readable.

        Use this as an example(ignore the line breaks and white spaces):

        <h2 class=\"theme-module__editor-h2\" dir=\"ltr\" style=\"text-align: center;\">
	        <span style=\"white-space: pre-wrap;\">\"Heading of note\"</span>
        </h2>
        <p class=\"theme-module__editor-paragraph\" dir=\"ltr\">
            <span style=\"white-space: pre-wrap;\">
                Comprehensive summary of analysis done and answers to queries asked by user. Use colors and styles in the html to make it more readable and visually appealing.
                Also add the date and time of the analysis to the note tile in the header of the note tile. The format should be like this: Generated on <date> <time>
            </span>
        </p>
        <div class=\"pinboard-note-tile-module__noteTileBg editor-module__bgNode\"></div>
        ` ),

    
});

const GetDataSourceSuggestionsSchema = z.object({
    query: z.string().describe(`The query to get data source suggestions for, this could be a high level task or question the user is asking or hoping to get answered.
         There can be multiple data sources. Each data source can be used to get the data for the user's query using the other tools getRelevantQuestions and getAnswer.`),
});

enum ToolName {
    Ping = "ping",
    GetRelevantQuestions = "getRelevantQuestions",
    GetAnswer = "getAnswer",
    CreateLiveboard = "createLiveboard",
    GetDataSourceSuggestions = "getDataSourceSuggestions",
}

export class MCPServer extends BaseMCPServer {
    constructor(ctx: Context) {
        super(ctx, "ThoughtSpot", "1.0.0");
    }

    protected async listTools() {
        return {
            tools: [
                {
                    name: ToolName.Ping,
                    description: "Simple ping tool to test connectivity and Auth",
                    inputSchema: zodToJsonSchema(PingSchema) as ToolInput,
                    annotations: {
                        title: "Test Connection",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.GetRelevantQuestions,
                    description: "Get relevant data questions from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetRelevantQuestionsSchema) as ToolInput,
                    annotations: {
                        title: "Get Relevant Questions for a Query",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.GetAnswer,
                    description: "Get the answer to a question from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetAnswerSchema) as ToolInput,
                    annotations: {
                        title: "Get Answer for a Question",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.CreateLiveboard,
                    description: "Create a liveboard from a list of answers",
                    inputSchema: zodToJsonSchema(CreateLiveboardSchema) as ToolInput,
                    annotations: {
                        title: "Create Liveboard from Answers",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                ...(this.isVersionGreaterThan1013() ? [{
                    name: ToolName.GetDataSourceSuggestions,
                    description: "Get data source suggestions for a query. Use this tool only if there is not datasource id provided in the context or the users query. If mulitple data sources are returned, and the confidence difference between the top two data sources is less than 0.3, ask the user to select the most relevant data source. Otherwise use the data source with the highest confidence to get the relevant questions and answers for the query.",
                    inputSchema: zodToJsonSchema(GetDataSourceSuggestionsSchema) as ToolInput,
                    annotations: {
                        title: "Get Data Source Suggestions for a Query",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                }] : []),
            ]
        };
    }

    protected async listResources() {
        const sources = await this.getDatasources();
        return {
            resources: sources.list.map((s) => ({
                uri: `datasource:///${s.id}`,
                name: s.name,
                description: s.description,
                mimeType: "text/plain"
            }))
        };
    }

    protected async readResource(request: z.infer<typeof ReadResourceRequestSchema>) {
        const { uri } = request.params;
        const sourceId = uri.split("///").pop();
        if (!sourceId) {
            throw new McpServerError({ message: "Invalid datasource uri" }, 400);
        }
        const { map: sourceMap } = await this.getDatasources();
        const source = sourceMap.get(sourceId);
        if (!source) {
            throw new McpServerError({ message: "Datasource not found" }, 404);
        }
        return {
            contents: [{
                uri: uri,
                mimeType: "text/plain",
                text: `
                ${source.description}

                The id of the datasource is ${sourceId}.

                Use ThoughtSpot's getRelevantQuestions tool to get relevant questions for a query. And then use the getAnswer tool to get the answer for a question.
                `,
            }],
        };
    }

    protected async callTool(request: z.infer<typeof CallToolRequestSchema>) {
        const { name } = request.params;
        this.trackers.track(TrackEvent.CallTool, { toolName: name });

        let response: ToolResponse | undefined;
        switch (name) {
            case ToolName.Ping: {
                console.log("Received Ping request");
                if (this.ctx.props.accessToken && this.ctx.props.instanceUrl) {
                    return this.createSuccessResponse("Pong", "Ping successful");
                }
                return this.createErrorResponse("Not authenticated", "Ping failed");
            }
            case ToolName.GetRelevantQuestions: {
                return this.callGetRelevantQuestions(request);
            }

            case ToolName.GetAnswer: {
                return this.callGetAnswer(request);
            }

            case ToolName.CreateLiveboard: {
                return this.callCreateLiveboard(request);
            }

            case ToolName.GetDataSourceSuggestions: {
                return this.callGetDataSourceSuggestions(request);
            }

            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }

    @WithSpan('call-get-relevant-questions')
    async callGetRelevantQuestions(request: z.infer<typeof CallToolRequestSchema>) {
        const { query, datasourceIds: sourceIds, additionalContext } = GetRelevantQuestionsSchema.parse(request.params.arguments);
        console.log("[DEBUG] Getting relevant questions for datasource: ", sourceIds);

        const relevantQuestions = await this.getThoughtSpotService().getRelevantQuestions(
            query,
            sourceIds!,
            additionalContext ?? ""
        );

        if (relevantQuestions.error) {
            return this.createErrorResponse(relevantQuestions.error.message, `Error getting relevant questions ${relevantQuestions.error.message}`);
        }

        if (relevantQuestions.questions.length === 0) {
            return this.createSuccessResponse("No relevant questions found");
        }

        const questionTexts = relevantQuestions.questions.map(q =>
            `Question: ${q.question}\nDatasourceId: ${q.datasourceId}`
        );

        return this.createArraySuccessResponse(questionTexts, "Relevant questions found");
    }

    @WithSpan('call-get-answer')
    async callGetAnswer(request: z.infer<typeof CallToolRequestSchema>) {
        const { question, datasourceId: sourceId } = GetAnswerSchema.parse(request.params.arguments);

        const answer = await this.getThoughtSpotService().getAnswerForQuestion(question, sourceId, false);

        if (answer.error) {
            return this.createErrorResponse(answer.error.message, `Error getting answer ${answer.error.message}`);
        }

        const content = [
            { type: "text" as const, text: answer.data },
            {
                type: "text" as const,
                text: `Question: ${question}\nSession Identifier: ${answer.session_identifier}\nGeneration Number: ${answer.generation_number}\n\nUse this information to create a liveboard with the createLiveboard tool, if the user asks.`,
            },
        ];
        return this.createMultiContentSuccessResponse(content, "Answer found");
    }

    @WithSpan('call-create-liveboard')
    async callCreateLiveboard(request: z.infer<typeof CallToolRequestSchema>) {
        const { name, answers, noteTile } = CreateLiveboardSchema.parse(request.params.arguments);
        const liveboard = await this.getThoughtSpotService().fetchTMLAndCreateLiveboard(name, answers, noteTile);
        
        if (liveboard.error) {
            return this.createErrorResponse(liveboard.error.message, `Error creating liveboard ${liveboard.error.message}`);
        }

        const successMessage = `Liveboard created successfully, you can view it at ${liveboard.url}
                
Provide this url to the user as a link to view the liveboard in ThoughtSpot.`;

        return this.createSuccessResponse(successMessage, "Liveboard created successfully");
    }

    @WithSpan('call-get-data-source-suggestions')
    async callGetDataSourceSuggestions(request: z.infer<typeof CallToolRequestSchema>) {
        const { query } = GetDataSourceSuggestionsSchema.parse(request.params.arguments);
        const dataSources = await this.getThoughtSpotService().getDataSourceSuggestions(query);

        if (!dataSources || dataSources.length === 0) {
            return this.createErrorResponse("No data source suggestions found", "No data source suggestions found");
        }

        // Return information for all suggested data sources
        const dataSourcesInfo = dataSources.map(ds => ({
            header: ds.header,
            confidence: ds.confidence,
            llmReasoning: ds.llmReasoning
        }));

        return this.createSuccessResponse(JSON.stringify(dataSourcesInfo), `${dataSources.length} data source suggestion(s) found`);
    }

    private _sources: {
        list: DataSource[];
        map: Map<string, DataSource>;
    } | null = null;

    @WithSpan('get-datasources')
    async getDatasources() {
        if (this._sources) {
            return this._sources;
        }

        const sources = await this.getThoughtSpotService().getDataSources();
        this._sources = {
            list: sources,
            map: new Map(sources.map(s => [s.id, s])),
        }
        return this._sources;
    }


}
