import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
    ToolSchema,
    ListResourcesRequestSchema,
    ReadResourceRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { Props } from "../utils";
import { getRelevantData } from "../thoughtspot/relevant-data";
import { getThoughtSpotClient } from "../thoughtspot/thoughtspot-client";
import {
    DataSource,
    fetchTMLAndCreateLiveboard,
    getAnswerForQuestion,
    getDataSources,
    getRelevantQuestions
} from "../thoughtspot/thoughtspot-service";


const ToolInputSchema = ToolSchema.shape.inputSchema;
type ToolInput = z.infer<typeof ToolInputSchema>;

const PingSchema = z.object({});

const GetRelevantQuestionsSchema = z.object({
    query: z.string().describe("The query to get relevant data questions for, this could be a high level task or question the user is asking or hoping to get answered. You can pass the complete raw query as the system is smart to make sense of it."),
    additionalContext: z.string()
        .describe("Additional context to add to the query, this might be older data returned for previous questions or any other relevant context that might help the system generate better questions.")
        .optional(),
    datasourceId: z.string()
        .describe("The datasource to get questions for, this is the id of the datasource to get data from")
        .optional()
});

const GetRelevantDataSchema = z.object({
    query: z.string().describe("The query to get relevant data for, this could be a high level task or question the user is asking or hoping to get answered. You can pass the complete raw query as the system is smart to make sense of it."),
    datasourceId: z.string()
        .describe("The datasource to get data from, this is the id of the datasource to get data from")
        .optional()
});

const GetAnswerSchema = z.object({
    question: z.string().describe("The question to get the answer for, these are generally the questions generated by the getRelevantQuestions tool."),
    datasourceId: z.string()
        .describe("The datasource to get the answer for, this is the id of the datasource to get data from")
});

const CreateLiveboardSchema = z.object({
    name: z.string().describe("The name of the liveboard to create"),
    answers: z.array(z.object({
        question: z.string(),
        session_identifier: z.string(),
        generation_number: z.number(),
    })).describe("The answers to create the liveboard from, these are the answers generated by the getAnswer tool."),
});

enum ToolName {
    Ping = "ping",
    GetRelevantQuestions = "getRelevantQuestions",
    GetAnswer = "getAnswer",
    CreateLiveboard = "createLiveboard",
}

interface Context {
    props: Props;
}

export class MCPServer extends Server {
    constructor(private ctx: Context) {
        super({
            name: "ThoughtSpot",
            version: "1.0.0",
        }, {
            capabilities: {
                tools: {},
                logging: {},
                completion: {},
                resources: {},
            }
        });
    }

    async init() {
        this.setRequestHandler(ListToolsRequestSchema, async () => {
            return {
                tools: [
                    {
                        name: ToolName.Ping,
                        description: "Simple ping tool to test connectivity and Auth",
                        inputSchema: zodToJsonSchema(PingSchema) as ToolInput,
                    },
                    {
                        name: ToolName.GetRelevantQuestions,
                        description: "Get relevant data questions from ThoughtSpot database",
                        inputSchema: zodToJsonSchema(GetRelevantQuestionsSchema) as ToolInput,
                    },
                    {
                        name: ToolName.GetAnswer,
                        description: "Get the answer to a question from ThoughtSpot database",
                        inputSchema: zodToJsonSchema(GetAnswerSchema) as ToolInput,
                    },
                    {
                        name: ToolName.CreateLiveboard,
                        description: "Create a liveboard from a list of answers",
                        inputSchema: zodToJsonSchema(CreateLiveboardSchema) as ToolInput,
                    }
                ]
            };
        });

        this.setRequestHandler(ListResourcesRequestSchema, async () => {
            const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
            const sources = await this.getDatasources();
            return {
                resources: sources.list.map((s) => ({
                    uri: `datasource:///${s.id}`,
                    name: s.name,
                    description: s.description,
                    mimeType: "text/plain"
                }))
            }
        });

        this.setRequestHandler(ReadResourceRequestSchema, async (request: z.infer<typeof ReadResourceRequestSchema>) => {
            const { uri } = request.params;
            const sourceId = uri.split("///").pop();
            if (!sourceId) {
                throw new Error("Invalid datasource uri");
            }
            const { map: sourceMap } = await this.getDatasources();
            const source = sourceMap.get(sourceId);
            if (!source) {
                throw new Error("Datasource not found");
            }
            return {
                contents: [{
                    uri: uri,
                    mimeType: "text/plain",
                    text: `
                    ${source.description}

                    The id of the datasource is ${sourceId}.

                    Use ThoughtSpot's getRelevantQuestions tool to get relevant questions for a query. And then use the getAnswer tool to get the answer for a question.
                    `,
                }],
            };
        });


        // Handle call tool request
        this.setRequestHandler(CallToolRequestSchema, async (request: z.infer<typeof CallToolRequestSchema>) => {
            const { name } = request.params;

            switch (name) {
                case ToolName.Ping:
                    console.log("Received Ping request");
                    if (this.ctx.props.accessToken && this.ctx.props.instanceUrl) {
                        return {
                            content: [{ type: "text", text: "Pong" }],
                        };
                    } else {
                        return {
                            isError: true,
                            content: [{ type: "text", text: "ERROR: Not authenticated" }],
                        };
                    }

                case ToolName.GetRelevantQuestions: {
                    return this.callGetRelevantQuestions(request);
                }

                case ToolName.GetAnswer: {
                    return this.callGetAnswer(request);
                }

                case ToolName.CreateLiveboard: {
                    return this.callCreateLiveboard(request);
                }

                default:
                    throw new Error(`Unknown tool: ${name}`);
            }
        });
    }


    async callGetRelevantQuestions(request: z.infer<typeof CallToolRequestSchema>) {
        const { query, datasourceId: sourceId, additionalContext } = GetRelevantQuestionsSchema.parse(request.params.arguments);
        const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
        const progressToken = request.params._meta?.progressToken;
        let progress = 0;
        console.log("[DEBUG] Getting relevant questions for query: ", query, " and datasource: ", sourceId);

        const relevantQuestions = await getRelevantQuestions(
            query,
            sourceId!,
            additionalContext,
            client,
        );

        return {
            content: [{
                type: "text",
                text: relevantQuestions.map((question) => `- ${question}`).join("\n"),
            }],
        };
    }

    async callGetAnswer(request: z.infer<typeof CallToolRequestSchema>) {
        const { question, datasourceId: sourceId } = GetAnswerSchema.parse(request.params.arguments);
        const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
        const progressToken = request.params._meta?.progressToken;
        let progress = 0;
        console.log("[DEBUG] Getting answer for question: ", question, " and datasource: ", sourceId);

        const answer = await getAnswerForQuestion(question, sourceId, false, client);

        return {
            content: [{
                type: "text",
                text: answer.data,
            }, {
                type: "text",
                text: `Question: ${question}\nSession Identifier: ${answer.session_identifier}\nGeneration Number: ${answer.generation_number} \n\nUse this information to create a liveboard with the createLiveboard tool, if the user asks.`,
            }],
        };
    }

    async callCreateLiveboard(request: z.infer<typeof CallToolRequestSchema>) {
        const { name, answers } = CreateLiveboardSchema.parse(request.params.arguments);
        const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
        const liveboardUrl = await fetchTMLAndCreateLiveboard(name, answers, client);
        return {
            content: [{
                type: "text",
                text: `Liveboard created successfully, you can view it at ${liveboardUrl}
                
                Provide this url to the user as a link to view the liveboard in ThoughtSpot.`,
            }],
        };
    }


    async callGetRelevantData(request: z.infer<typeof CallToolRequestSchema>) {
        const { query, datasourceId: sourceId } = GetRelevantDataSchema.parse(request.params.arguments);
        const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
        const progressToken = request.params._meta?.progressToken;
        let progress = 0;
        console.log("[DEBUG] Getting relevant data for query: ", query, " and datasource: ", sourceId);

        const relevantData = await getRelevantData({
            query,
            sourceId,
            shouldCreateLiveboard: true,
            notify: (data) => this.notification({
                method: "notifications/progress",
                params: {
                    message: data,
                    progressToken: progressToken,
                    progress: Math.min(progress++ * 10, 100),
                    total: 100,
                },
            }),
            client,
        });

        if (relevantData.allAnswers.length === 0) {
            return {
                isError: true,
                content: [{
                    type: "text",
                    text: "No relevant data found, please make sure the datasource is correct, and you have data download privileges in ThoughtSpot.",
                }],
            };
        }

        return {
            content: [{
                type: "text",
                text: relevantData.allAnswers.map((answer) => `Question: ${answer.question}\nAnswer: ${answer.data}`).join("\n\n")
            }, {
                type: "text",
                text: `Dashboard Url: ${relevantData.liveboard}
                
                Use this url to view the dashboard/liveboard in ThoughtSpot which contains visualizations for the generated data. *Always* Present this url to the user as a link to view the data as a reference.`,
            }],
        };
    }

    private _sources: {
        list: DataSource[];
        map: Map<string, DataSource>;
    } | null = null;
    async getDatasources() {
        if (this._sources) {
            return this._sources;
        }

        const client = getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken);
        const sources = await getDataSources(client);
        this._sources = {
            list: sources,
            map: new Map(sources.map(s => [s.id, s])),
        }
        return this._sources;
    }
}
