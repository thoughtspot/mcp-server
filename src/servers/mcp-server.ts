import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
    CallToolRequestSchema,
    ListToolsRequestSchema,
    ToolSchema,
    ListResourcesRequestSchema,
    ReadResourceRequestSchema
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import type { Props } from "../utils";
import { McpServerError } from "../utils";
import { getThoughtSpotClient } from "../thoughtspot/thoughtspot-client";
import {
    ThoughtSpotService,
    type DataSource
} from "../thoughtspot/thoughtspot-service";
import { MixpanelTracker } from "../metrics/mixpanel/mixpanel";
import { Trackers, type Tracker, TrackEvent } from "../metrics";
import { context, type Span, SpanStatusCode, trace } from "@opentelemetry/api";
import { getActiveSpan, WithSpan } from "../metrics/tracing/tracing-utils";

const ToolInputSchema = ToolSchema.shape.inputSchema;
type ToolInput = z.infer<typeof ToolInputSchema>;

const PingSchema = z.object({});

const GetRelevantQuestionsSchema = z.object({
    query: z.string().describe("The query to get relevant data questions for, this could be a high level task or question the user is asking or hoping to get answered. Do minimal processing of the original question. You can even pass the complete raw query as it is, the system is smart to make sense of it as it has access to the entire schema. Do not add analytical hints or directions."),
    additionalContext: z.string()
        .describe("Additional context to add to the query, this might be older data returned for previous questions or any other relevant context that might help the system generate better questions.")
        .optional(),
    datasourceIds: z.array(z.string())
        .describe("The datasources to get questions for, this is the ids of the datasources to get data from. Each id is a GUID string.")
});

const GetAnswerSchema = z.object({
    question: z.string().describe("The question to get the answer for, these are generally the questions generated by the getRelevantQuestions tool."),
    datasourceId: z.string()
        .describe("The datasource to get the answer for, this is the id of the datasource to get data from")
});

const CreateLiveboardSchema = z.object({
    name: z.string().describe("The name of the liveboard to create"),
    answers: z.array(z.object({
        question: z.string(),
        session_identifier: z.string(),
        generation_number: z.number(),
    })).describe("The answers to create the liveboard from, these are the answers generated by the getAnswer tool."),
    noteTile: z.string().describe(`
        Create a summary of the answers to the queries asked by the user along with all the analysis done on the data.
        The output format is an html note tile which can have custom styles and formatting. Use emojis, styling and icons to make it more visually appealing.
        Follow these MANDATORY rules for styling:
        - Put the whole note tile in a single line and no line breaks. Also there should be no unnecessary white spaces.
        - The html output in the note tile can have white spaces. Use <br> or <tab> if needed to use white spaces in the note tile.
        - Use padding, margin and line height to create space between the elements in the note tile and make it more readable.

        Use this as an example(ignore the line breaks and white spaces):

        <h2 class=\"theme-module__editor-h2\" dir=\"ltr\" style=\"text-align: center;\">
	        <span style=\"white-space: pre-wrap;\">\"Heading of note\"</span>
        </h2>
        <p class=\"theme-module__editor-paragraph\" dir=\"ltr\">
            <span style=\"white-space: pre-wrap;\">
                Comprehensive summary of analysis done and answers to queries asked by user. Use colors and styles in the html to make it more readable and visually appealing.
                Also add the date and time of the analysis to the note tile in the header of the note tile. The format should be like this: Generated on <date> <time>
            </span>
        </p>
        <div class=\"pinboard-note-tile-module__noteTileBg editor-module__bgNode\"></div>
        ` ),

    
});

enum ToolName {
    Ping = "ping",
    GetRelevantQuestions = "getRelevantQuestions",
    GetAnswer = "getAnswer",
    CreateLiveboard = "createLiveboard",
}

interface Context {
    props: Props;
}

// Response utility types
type ContentItem = {
    type: "text";
    text: string;
};

type SuccessResponse = {
    content: ContentItem[];
};

type ErrorResponse = {
    isError: true;
    content: ContentItem[];
};

type ToolResponse = SuccessResponse | ErrorResponse;

export class MCPServer extends Server {
    private trackers: Trackers = new Trackers();
    private sessionInfo: any;
    constructor(private ctx: Context) {
        super({
            name: "ThoughtSpot",
            version: "1.0.0",
        }, {
            capabilities: {
                tools: {},
                logging: {},
                completion: {},
                resources: {},
            }
        });
    }

    private getThoughtSpotService() {
        return new ThoughtSpotService(getThoughtSpotClient(this.ctx.props.instanceUrl, this.ctx.props.accessToken));
    }

    /**
     * Initialize span with common attributes (user_guid and instance_url)
     */
    private initSpanWithCommonAttributes(span: Span | undefined): void {
        span?.setAttributes({
            user_guid: this.sessionInfo.userGUID,
            instance_url: this.ctx.props.instanceUrl,
        });
    }

    /**
     * Create a standardized error response
     */
    private createErrorResponse(span: Span | undefined, message: string, statusMessage?: string): ErrorResponse {
        span?.setStatus({ code: SpanStatusCode.ERROR, message: statusMessage || message });
        return {
            isError: true,
            content: [{ type: "text", text: `ERROR: ${message}` }],
        };
    }

    /**
     * Create a standardized success response with a single message
     */
    private createSuccessResponse(span: Span | undefined, message: string, statusMessage?: string): SuccessResponse {
        span?.setStatus({ code: SpanStatusCode.OK, message: statusMessage || message });
        return {
            content: [{ type: "text", text: message }],
        };
    }

    /**
     * Create a standardized success response with multiple content items
     */
    private createMultiContentSuccessResponse(span: Span | undefined, content: ContentItem[], statusMessage: string): SuccessResponse {
        span?.setStatus({ code: SpanStatusCode.OK, message: statusMessage });
        return {
            content,
        };
    }

    /**
     * Create a standardized success response with an array of text items
     */
    private createArraySuccessResponse(span: Span | undefined, texts: string[], statusMessage: string): SuccessResponse {
        span?.setStatus({ code: SpanStatusCode.OK, message: statusMessage });
        return {
            content: texts.map(text => ({ type: "text", text })),
        };
    }

    async init() {
        this.sessionInfo = await this.getThoughtSpotService().getSessionInfo();
        const mixpanel = new MixpanelTracker(
            this.sessionInfo,
            this.ctx.props.clientName
        );
        this.addTracker(mixpanel);
        this.trackers.track(TrackEvent.Init);

        this.setRequestHandler(ListToolsRequestSchema, async () => {
            return this.listTools();
        });

        this.setRequestHandler(ListResourcesRequestSchema, async () => {
            return this.listResources();
        });

        this.setRequestHandler(ReadResourceRequestSchema, async (request: z.infer<typeof ReadResourceRequestSchema>) => {
            return this.readResource(request);
        });

        // Handle call tool request
        this.setRequestHandler(CallToolRequestSchema, async (request: z.infer<typeof CallToolRequestSchema>) => {
            return this.callTool(request);
        });
    }

    @WithSpan('list-tools')
    async listTools() {
        const span = getActiveSpan();
        this.initSpanWithCommonAttributes(span);

        return {
            tools: [
                {
                    name: ToolName.Ping,
                    description: "Simple ping tool to test connectivity and Auth",
                    inputSchema: zodToJsonSchema(PingSchema) as ToolInput,
                    annotations: {
                        title: "Test Connection",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.GetRelevantQuestions,
                    description: "Get relevant data questions from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetRelevantQuestionsSchema) as ToolInput,
                    annotations: {
                        title: "Get Relevant Questions for a Query",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.GetAnswer,
                    description: "Get the answer to a question from ThoughtSpot database",
                    inputSchema: zodToJsonSchema(GetAnswerSchema) as ToolInput,
                    annotations: {
                        title: "Get Answer for a Question",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                },
                {
                    name: ToolName.CreateLiveboard,
                    description: "Create a liveboard from a list of answers",
                    inputSchema: zodToJsonSchema(CreateLiveboardSchema) as ToolInput,
                    annotations: {
                        title: "Create Liveboard from Answers",
                        readOnlyHint: true,
                        destructiveHint: false,
                    },
                }
            ]
        };
    }

    @WithSpan('list-datasources')
    async listResources() {
        const span = getActiveSpan();
        this.initSpanWithCommonAttributes(span);

        const sources = await this.getDatasources();
        return {
            resources: sources.list.map((s) => ({
                uri: `datasource:///${s.id}`,
                name: s.name,
                description: s.description,
                mimeType: "text/plain"
            }))
        };
    }

    @WithSpan('read-datasources')
    async readResource(request: z.infer<typeof ReadResourceRequestSchema>) {
        const span = getActiveSpan();
        this.initSpanWithCommonAttributes(span);

        const { uri } = request.params;
        const sourceId = uri.split("///").pop();
        if (!sourceId) {
            throw new McpServerError({ message: "Invalid datasource uri" }, 400);
        }
        const { map: sourceMap } = await this.getDatasources();
        const source = sourceMap.get(sourceId);
        if (!source) {
            throw new McpServerError({ message: "Datasource not found" }, 404);
        }
        return {
            contents: [{
                uri: uri,
                mimeType: "text/plain",
                text: `
                ${source.description}

                The id of the datasource is ${sourceId}.

                Use ThoughtSpot's getRelevantQuestions tool to get relevant questions for a query. And then use the getAnswer tool to get the answer for a question.
                `,
            }],
        };
    }

    @WithSpan('call-tool')
    async callTool(request: z.infer<typeof CallToolRequestSchema>) {
        const { name } = request.params;
        this.trackers.track(TrackEvent.CallTool, { toolName: name });

        const span = getActiveSpan();
        this.initSpanWithCommonAttributes(span);

        let response: ToolResponse | undefined;
        switch (name) {
            case ToolName.Ping: {
                console.log("Received Ping request");
                if (this.ctx.props.accessToken && this.ctx.props.instanceUrl) {
                    return this.createSuccessResponse(span, "Pong", "Ping successful");
                }
                return this.createErrorResponse(span, "Not authenticated", "Ping failed");
            }
            case ToolName.GetRelevantQuestions: {
                return this.callGetRelevantQuestions(request);
            }

            case ToolName.GetAnswer: {
                return this.callGetAnswer(request);
            }

            case ToolName.CreateLiveboard: {
                return this.callCreateLiveboard(request);
            }

            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }

    @WithSpan('call-get-relevant-questions')
    async callGetRelevantQuestions(request: z.infer<typeof CallToolRequestSchema>) {
        const { query, datasourceIds: sourceIds, additionalContext } = GetRelevantQuestionsSchema.parse(request.params.arguments);
        console.log("[DEBUG] Getting relevant questions for datasource: ", sourceIds);
        const span = getActiveSpan();

        const relevantQuestions = await this.getThoughtSpotService().getRelevantQuestions(
            query,
            sourceIds!,
            additionalContext ?? ""
        );

        if (relevantQuestions.error) {
            return this.createErrorResponse(span, relevantQuestions.error.message, `Error getting relevant questions ${relevantQuestions.error.message}`);
        }

        if (relevantQuestions.questions.length === 0) {
            return this.createSuccessResponse(span, "No relevant questions found");
        }

        const questionTexts = relevantQuestions.questions.map(q =>
            `Question: ${q.question}\nDatasourceId: ${q.datasourceId}`
        );

        return this.createArraySuccessResponse(span, questionTexts, "Relevant questions found");
    }

    @WithSpan('call-get-answer')
    async callGetAnswer(request: z.infer<typeof CallToolRequestSchema>) {
        const { question, datasourceId: sourceId } = GetAnswerSchema.parse(request.params.arguments);
        const span = getActiveSpan();

        const answer = await this.getThoughtSpotService().getAnswerForQuestion(question, sourceId, false);

        if (answer.error) {
            return this.createErrorResponse(span, answer.error.message, `Error getting answer ${answer.error.message}`);
        }

        const content: ContentItem[] = [
            { type: "text", text: answer.data },
            {
                type: "text",
                text: `Question: ${question}\nSession Identifier: ${answer.session_identifier}\nGeneration Number: ${answer.generation_number}\n\nUse this information to create a liveboard with the createLiveboard tool, if the user asks.`,
            },
        ];
        return this.createMultiContentSuccessResponse(span, content, "Answer found");
    }

    @WithSpan('call-create-liveboard')
    async callCreateLiveboard(request: z.infer<typeof CallToolRequestSchema>) {
        const { name, answers, noteTile } = CreateLiveboardSchema.parse(request.params.arguments);
        const liveboard = await this.getThoughtSpotService().fetchTMLAndCreateLiveboard(name, answers, noteTile);
        const span = getActiveSpan();

        if (liveboard.error) {
            return this.createErrorResponse(span, liveboard.error.message, `Error creating liveboard ${liveboard.error.message}`);
        }

        const successMessage = `Liveboard created successfully, you can view it at ${liveboard.url}
                
Provide this url to the user as a link to view the liveboard in ThoughtSpot.`;

        return this.createSuccessResponse(span, successMessage, "Liveboard created successfully");
    }

    private _sources: {
        list: DataSource[];
        map: Map<string, DataSource>;
    } | null = null;

    @WithSpan('get-datasources')
    async getDatasources() {
        if (this._sources) {
            return this._sources;
        }

        const sources = await this.getThoughtSpotService().getDataSources();
        this._sources = {
            list: sources,
            map: new Map(sources.map(s => [s.id, s])),
        }
        return this._sources;
    }

    async addTracker(tracker: Tracker) {
        this.trackers.add(tracker);
    }
}
